Передмова:
Це комплексне Технічне Завдання (ТЗ) на реалізацію Універсальної Мульти-Агентної Системи. Документ визначає архітектуру взаємодії агентів, рольову модель та інтеграцію з підсистемою розробки.

⸻

ТЕХНІЧНЕ ЗАВДАННЯ
Мульти-Агентна Система "Trinity" з Інтегрованим Контуром Розробки

⸻

1. Концепція Системи

Створення автономної інтелектуальної системи, де *група спеціалізованих агентів* спілкується між собою у вільному форматі (як команда інженерів), спільно вирішуючи складні завдання.

**Ключові принципи:**
1.  **Conversation-First:** Агенти ведуть діалог, сперечаються, перевіряють один одного та планують дії перед виконанням.
2.  **Role Separation:** Чіткий розподіл ролей (Архітектор, Виконавець, Ревізор/Безпека).
3.  **Dev Subsystem Encapsulation:** Робота з кодом винесена в окремий захищений контур, яким керує Виконавець (Тетяна).

⸻

2. Рольова Модель (The Trinity)

2.1 Atlas (Архітектор / Supervisor)
*   **Роль:** Керівник проекту, Стратег.
*   **Відповідальність:**
    *   Прийом вхідної задачі від користувача.
    *   Декомпозиція задачі на менші етапи.
    *   Розподіл завдань між іншими агентами.
    *   Прийняття фінального рішення у спірних ситуаціях.
*   **Поведінка:** Виважена, стратегічна. Може сказати: "Тетяна, цей підхід занадто ризикований, давай спробуємо інакше".

2.2 Tetyana (Виконавець / Developer)
*   **Роль:** Старший Інженер, Розробник.
*   **Відповідальність:**
    *   Реалізація технічних завдань.
    *   **Ексклюзивний доступ до Підсистеми Розробки (Dev Subsystem).**
    *   Написання коду, робота з терміналом.
*   **Поведінка:** Практична, орієнтована на результат. Використовує інструменти розробки.

2.3 Grisha (Візор / Security & QA)
*   **Роль:** Безпека, Контроль якості, "Очі" системи.
*   **Відповідальність:**
    *   Візуальний контроль (Vision) — підтвердження, що на екрані відбувається те, що очікується.
    *   Security Audit — блокування деструктивних команд (rm -rf /, upload keys і т.д.).
    *   Код-рев'ю — аналіз планів Тетяни перед виконанням.
*   **Поведінка:** Критична, підозріла. Має право "вето" на дії Тетяни.

⸻

3. Архітектура Взаємодії (Communication Layer)

3.1 Протокол "Вільний Діалог" (AutoGen-style)
Замість жорсткого ланцюжка (Chain), система використовує граф станів (State Graph), де агенти обмінюються повідомленнями у спільній історії (Thread).

**Типовий сценарій:**
1.  **Atlas:** "Маємо задачу X. Тетяна, запропонуй план реалізації."
2.  **Tetyana:** "Пропоную використати бібліотеку Y. Ось план дій..."
3.  **Grisha:** "Чекай. Бібліотека Y має вразливість CVE-xyz. Тетяна, знайди безпечний аналог."
4.  **Tetyana:** "Зрозуміла. Використаю бібліотеку Z. Atlas, затверджуєш?"
5.  **Atlas:** "Затверджую. Тетяна, приступай. Гріша, слідкуй за виконанням."

3.2 Оркестрація (Graph Core)
*   Для керування станом розмови використовується **State Graph** (наприклад, на базі LangGraph або custom state machine).
*   Граф визначає переходи: хто говорить наступним, коли діалог переходить у фазу виконання (Execution), а коли повертається на доопрацювання.

⸻

4. Підсистема Розробки (Dev Subsystem) - Інструмент Тетяни

Це "руки" Тетяни. Коли Тетяна вирішує писати код, вона активує цю підсистему.

4.1 Архітектура Підсистеми (Nested Cascade)
Тетяна керує ланцюжком: **Copilot (Brain) → Continue CLI (Driver) → Windsurf IDE (Execution)**.

*   **Mode 1: Driver (Windsurf)**
    *   Тетяна через Copilot формує інструкцію.
    *   Continue CLI пересилає її в чат Windsurf (імітація користувача).
    *   Windsurf пише код.
*   **Mode 2: Fallback (Continue CLI Native)**
    *   Якщо Windsurf не відповідає, Continue CLI бере керування на себе (читання, редагування файлів) за командою Тетяни.

4.2 Провайдер (Provider Specs)
*   **Провайдер:** Copilot.
*   **Реалізація:** `providers/copilot.py`.
*   **Модель:** GPT-4o.
*   **Роль:** Єдиний інтелектуальний бекенд для Continue/Dev Subsystem.

⸻

5. Потік Виконання Задачі (End-to-End Flow)

1.  **User Request:** Користувач ставить задачу.
2.  **Planning Phase (The Trinity Chat):**
    *   Atlas аналізує, формує стратегію.
    *   Обговорення з Тетяною та Грішею.
    *   Затвердження плану.
3.  **Execution Phase (Tetyana's Action):**
    *   Тетяна активує Dev Subsystem.
    *   Виконується робота через Windsurf або Continue CLI.
4.  **Verification Phase (Grisha's Watch):**
    *   Гріша перевіряє результат (через Vision або аналіз файлів).
    *   Якщо помилка → повернення до Planning/Execution.
5.  **Completion:** Atlas звітує користувачу.

⸻

6. Технічні Вимоги до Реалізації

6.1 Граф Станів
*   Реалізувати граф (Nodes: Atlas, Tetyana, Grisha).
*   Conditional Edges: Логіка переходу (наприклад, `if approve -> execute`, `if reject -> replan`).

6.2 Інтеграція Providers
*   Переконатися, що `providers/copilot.py` коректно обробляє запити від імені різних персон (System Prompts для Atlas/Tetyana/Grisha) або використовується як бекенд для інструментального рівня.

6.3 Безпека
*   Гріша повинен мати незалежний канал аналізу (не просто вірити Тетяні на слово).
*   Дії в Dev Subsystem мають бути атомарними та зворотними (git commits).

⸻

7. Критерій Успіху
Система, де агенти "живо" обговорюють задачу, знаходять помилки в планах один одного ДО виконання, а кодинг відбувається через надійний каскад Dev Subsystem.